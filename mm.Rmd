
```{r}
pSheet_final <- read.csv("molly_composite.csv", header = TRUE)
```

```{r}
library(tidyr)
library(dplyr)
setwd("~/fri/voi-vod")
source("sources/functions.R")
```

```{r}
summaryResults_final <- pSheet_final %>%
    # Own beliefs only (drop reciprocal questions & VOD)
    select(-c(starts_with("S_"), starts_with("E_"), contains("VoD"), "X"))
```

```{r}
if (FALSE) {  # This was for conditional tree data (pSheet_final_supers.csv)
  # Reshape this so that each row is a question-person pair. Question is the ID, person is the letters before the first underscore

  reshapedData <- summaryResults_final %>%
    pivot_longer(cols = -ID, names_to = "variable", values_to = "value")

  # separate person from other variables
  reshapedData <- reshapedData %>%
    separate(variable, into = c("person", "measure"), sep = "_", extra = "merge") %>%
    pivot_wider(names_from = measure, values_from = value)

  # view reshaped data
  head(reshapedData)
}

reshapedData <- pSheet_final %>%
  rename(person = Person)
```

```{r}
# Why are there still NaN's in VoI_log? NA's are when they didn't answer the question (fine), but NaN's are perplexing
inconsistent <- reshapedData %>% filter(is.nan(VoI_log)) %>%
  select(person, Camp, ID, PU, Pc, PUc, punotc, VoI_log)

write.csv(inconsistent, "inconsistent.csv", row.names = FALSE)

claireWarning <- reshapedData %>%
  filter(grepl("Claire", person), grepl("Warning shot", ID))

claireWarning %>%
  rowwise() %>%
  mutate(punotc = punotc(Pc, PUc, PU)) %>%
  mutate(VoI_log = VoI_log(PU, PUc, Pc, punotc))
```

```{r}
# Add log VoI (KL Divergence) now if it's P8 data
reshapedData <- reshapedData %>%
  rowwise() %>%
  mutate(punotc = punotc(Pc, PUc, PU))
```

```{r}
# For rows with incoherent forecasts, make PU, Pc, PUc, punotc all NA
reshapedData <- reshapedData %>%
  mutate(PU = ifelse(PUc * Pc > PU, NA, PU))
```

```{r}
reshapedData <- reshapedData %>%
  filter(!is.na(PU)) %>%
  mutate(VoI_log = VoI_log(PU, PUc, Pc, punotc)) %>%
  mutate(person = paste0(person, " (", Camp, ")"))
```

```{r}
# Add direction of update
reshapedData <- reshapedData %>%
    mutate(direction = ifelse(PUc > PU, "up", ifelse(PUc == PU, "no change", "down")))
```

```{r}
# load necessary library
library(ggplot2)
library(scales)

# What's the max VoI_log for just the skeptic camp?
max(reshapedData$VoI_log[reshapedData$Camp == "Skeptical"], na.rm = TRUE)

# Calculate medians (so we can order x axis by median VoI)
central_tendency <- reshapedData %>%
  group_by(ID) %>%
  summarise(median_voil = median(VoI_log, na.rm = TRUE),
            mean_voil = mean(VoI_log, na.rm = TRUE))

# Order ID levels by median (or mean)
reshapedData$ID <- factor(reshapedData$ID, levels = central_tendency$ID[order(central_tendency$median_voil)])

# create the plot
ggplot(reshapedData, aes(x = ID, y = VoI_log, color = Camp, shape = direction)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  scale_y_continuous(trans = pseudo_log_trans(base = 10), breaks = c(0, 0.0001, 0.001, 0.01), limits=c(0, 0.0075)) +
  labs(x = "Question ID", y = "VOI_log", color = "Person", shape = "Direction") +
  scale_shape_manual(values = c("up" = 17, "down" = 25, "no change" = 8)) # 19 and 17 are the shapes for the points

ggsave("VoI_log.png", width = 18, height = 10)
```

```{r}
VoD_log_geomean <- function(dt, id1, id2) {
  pu_a <- dt[dt$person == id1, "PU"]
  pu_b <- dt[dt$person == id2, "PU"]
  puc_a <- dt[dt$person == id1, "PUc"]
  puc_b <- dt[dt$person == id2, "PUc"]
  pc_a <- dt[dt$person == id1, "Pc"]
  pc_b <- dt[dt$person == id2, "Pc"]
  punotc_a <- dt[dt$person == id1, "punotc"]
  punotc_b <- dt[dt$person == id2, "punotc"]

  initDis <- pu_a * log(pu_a / pu_b) + (1 - pu_a) * log((1 - pu_a) / (1 - pu_b)) +
    pu_b * log(pu_b / pu_a) + (1 - pu_b) * log((1 - pu_b) / (1 - pu_a))
  expDis <- (puc_a * log(puc_a / puc_b) + (1 - puc_a) * log((1 - puc_a) / (1 - puc_b)) +
    puc_b * log(puc_b / puc_a) + (1 - puc_b) * log((1 - puc_b) / (1 - puc_a))) *
    sqrt(pc_a * pc_b) +
    (punotc_a * log(punotc_a / punotc_b) + (1 - punotc_a) * log((1 - punotc_a) / (1 - punotc_b)) +
      punotc_b * log(punotc_b / punotc_a) + (1 - punotc_b) * log((1 - punotc_b) / (1 - punotc_a))) *
      sqrt(punotc_a * punotc_b)
  answer <- initDis * log(initDis / expDis) + (1 - initDis) * log((1 - initDis) / (1 - expDis)) + expDis * log(expDis / initDis) + (1 - expDis) * log((1 - expDis) / (1 - initDis))
  return(answer[1,1])
}
```

```{r}
if (FALSE) {
  CG30a <- reshapedData %>%
      filter(ID == "CG30a") %>%
      select(person, PU, PUc, Pc, punotc)

  people <- unique(cg30a$person)
  numpeople <- length(people)

  # create a symmetric adjacency matrix where each cell is the vod between the two people
  cg30a_vod <- matrix(0, nrow = numpeople, ncol = numpeople)
  rownames(cg30a_vod) <- cg30a$person
  colnames(cg30a_vod) <- cg30a$person

  for (i in 1:(numpeople-1)) {
      for (j in (i+1):numpeople) {
          cg30a_vod[i, j] <- VoD_log_geomean(cg30a, people[i], people[j])
          cg30a_vod[j, i] <- cg30a_vod[i, j]  # use the same value for the 'mirror' cell
      }
  }
}
```

```{r}
# Fiedler ordering & heatmap

# install necessary packages
library(igraph)
library(pheatmap)

make_fiedler_ordered_heatmap <- function(mat, title) {
  #' @param mat a matrix of pairwise VoD for ONE QUESTION

  # NOTE: NOT SURE IF THIS IS THE RIGHT THING TO DO
  mat[is.nan(mat)] <- 0
  mat[is.na(mat)] <- 0

  # create an igraph object
  g <- graph_from_adjacency_matrix(mat, mode = "undirected", weighted = TRUE, diag = FALSE)

  # calculate Laplacian matrix
  laplacian <- laplacian_matrix(g)

  # compute eigenvalues and eigenvectors
  eigen_info <- eigen(laplacian)

  # get the Fiedler vector - the eigenvector of the second smallest eigenvalue
  fiedler_vector <- eigen_info$vectors[,which.min(eigen_info$values[eigen_info$values > min(eigen_info$values)])]

  # create an ordering based on the Fiedler vector
  fiedler_ordering <- order(fiedler_vector)

  # reorder the adjacency matrix
  mat_reordered <- mat[fiedler_ordering, fiedler_ordering]

  # Start png device
  png(paste0("p8_heatmaps/heatmap_", title, ".png"), width = 800, height = 800)

  # create a heatmap
  pheatmap(mat_reordered, main = title)

  # Close device
  dev.off()
}

```

```{r}
# Select the unique reshapedData IDs
uniqueIDs <- unique(reshapedData$ID)

for (question in uniqueIDs) {
  questionData <- reshapedData %>%
    filter(ID == question) %>%
    select(person, PU, PUc, Pc, punotc)
  people <- unique(questionData$person)
  numpeople <- length(people)

  # create a symmetric adjacency matrix where each cell is the vod between the two people
  vod_matrix <- matrix(0, nrow = numpeople, ncol = numpeople)
  rownames(vod_matrix) <- questionData$person
  colnames(vod_matrix) <- questionData$person

  for (i in 1:(numpeople-1)) {
      for (j in (i+1):numpeople) {
          vod_matrix[i, j] <- VoD_log_geomean(questionData, people[i], people[j])
          vod_matrix[j, i] <- vod_matrix[i, j]  # use the same value for the 'mirror' cell
      }
  }

  make_fiedler_ordered_heatmap(vod_matrix, question)
}
```

```{r}
# Group by question, get geomean log VoI for each question
aggVoi <- reshapedData %>%
  group_by(ID) %>%
  summarise(geomean_voi = exp(mean(log(VoI_log), na.rm = TRUE)),
            mean_voi = mean(VoI_log, na.rm = TRUE),
            median_voi = median(VoI_log, na.rm = TRUE))
```

```{r}
# Order ID levels
print(aggVoi %>% arrange(median_voi), n = 40)
```

```{r}
# How many NA's are there in reshapedData$VoI_log? NA's bad, should fix
sum(is.na(reshapedData$VoI_log))
sum(reshapedData$VoI_log == 0)
```

```{r}
# Is it ever the case that PU is zero but PUc is not? That would be inconsistent
reshapedData %>%
  filter(PU == 0 & PUc != 0)
```

```{r}
# Histogram of median log VoI's
ggplot(aggVoi, aes(x = median_voi)) +
  geom_histogram(binwidth = 0.00001) +
  labs(x = "Median log VoI", y = "Count")

ggsave("median_voi_hist.png", width = 10, height = 10)
```

```{r}
# Histogram of mean log VoI's
ggplot(aggVoi, aes(x = mean_voi)) +
  geom_histogram(binwidth = 0.001) +
  labs(x = "Mean log VoI", y = "Count")

ggsave("mean_voi_hist.png", width = 10, height = 10)
```
